function h(e,t){let r=O(e,t,"x");if(r===!1)return!1;let n=O(e,t,"y");return n===!1?!1:{...r,...n}}var u={x:"w",y:"h"};function O(e,t,r="x"){let n=Math.min(e[r],t[r]),o=Math.max(e[r]+e[u[r]],t[r]+t[u[r]]),c=e[u[r]]+t[u[r]],i=o-n;return i<=c?{[r]:Math.max(e[r],t[r]),[u[r]]:c-i}:!1}function R(e,t){return e.x>=t.x&&e.x<=t.x+t.w&&e.y>=t.y&&e.y<=t.y+t.h}import{Vector as b}from"@papit/game-vector";function v(e,...t){if(t.length!==3)throw new Error(`${t} is not a triangle`);return!(!p(e,t,0)||!p(e,t,1)||!p(e,t,2))}function p(e,t,r){let n=b.Subtract(t[(r+1)%t.length],t[r]),o=b.Subtract(e,t[r]);return b.Cross(n,o)>=0}import{Vector as j}from"@papit/game-vector";function J(e,t){let r=j.Subtract(t,e),n=r.magnitude;if(n<=e.r+t.r){let o=(e.r+t.r-n)/2,c=e.r**2,i=(c-t.r**2+n**2)/(2*n),s=Math.sqrt(c-i**2),f=j.Add(e,{x:i*r.x/n,y:i*r.y/n}),l=f.Add({x:s*r.y/n,y:-s*r.x/n}),x=f.Add({x:-s*r.y/n,y:s*r.x/n});return{va:l,vb:x,vc:f,r:o,a:i,h:s}}return!1}function K(e,t){return j.Distance(e,t)<=t.r}import{Vector as m}from"@papit/game-vector";function y(e,t,r,n){let o=m.Subtract(t,e),c=m.Subtract(n,r),i=m.Cross(o,c);if(i===0)return!1;let s=m.Subtract(r,e),f=m.Cross(s,c)/i,l=m.Cross(s,o)/i;return{x:e.x+f*o.x,y:e.y+f*o.y,t:f,u:l}}function V(e,t,r,n){let o=y(e,t,r,n);return o===!1?!1:o.t>=0&&o.t<=1&&o.u>=0&&o.u<=1?o:!1}import{Vector as _}from"@papit/game-vector";function ct(e,t){for(let r=0;r<t.triangles.length;r+=3){let n=t.verticies[t.triangles[r]],o=t.verticies[t.triangles[r+1]],c=t.verticies[t.triangles[r+2]];if(v(e,n,o,c))return[!0,[n,o,c]]}return!1}function it(e,t){let r=[e,_.Add(e,{x:1e4,y:0})],n=0;for(let o=0;o<t.verticies.length;o++){let c=t.verticies[o],i=t.verticies[(o+1)%t.verticies.length];V(r[0],r[1],c,i)&&n++}return n%2===1}import{Vector as a}from"@papit/game-vector";function bt(e,t){let r=e.boundary,n=t.boundary;if(r&&n&&!h(r,n))return!1;let o=a.Subtract(e.center,t.center);return e.concave?t.concave?A(e,t,o):d(e,t,o):t.concave?d(t,e,o):g(e,t,o)}function g(e,t,r){let n=S(e,t);if(!n)return!1;let o=S(t,e);if(!o)return!1;let c=o;n.depth<o.depth&&(c=n);let i=c.axis.magnitude,s=c.axis.normalise();return a.Dot(r,s)>0&&s.mul(-1),{depth:c.depth/i,normal:s}}function S(e,t){let r=Number.MAX_SAFE_INTEGER,n=a.Zero;for(let o=0;o<e.verticies.length;o++){let c=a.Perpendicular(e.verticies[o],e.verticies[(o+1)%e.verticies.length]).normalise(),[i,s]=P(e.verticies,c),[f,l]=P(t.verticies,c);if(i>=l||f>=s)return!1;let x=Math.min(l-i,s-f);x<r&&(r=x,n=c)}return{axis:n,depth:r}}function P(e,t){let r=Number.MAX_SAFE_INTEGER,n=Number.MIN_SAFE_INTEGER;for(let o of e){let c=a.Dot(o,t);c<r&&(r=c),c>n&&(n=c)}return[r,n]}function d(e,t,r){let n={verticies:[],triangles:[]};for(let o=0;o<e.triangles.length/3;o++){n.verticies=e.getTriangle(o);let c=g(n,t,r);if(c)return c}}function A(e,t,r){let n={verticies:[],triangles:[]},o={verticies:[],triangles:[]};for(let c=0;c<e.triangles.length/3;c++){n.verticies=e.getTriangle(c);for(let i=0;i<t.triangles.length/3;i++){o.verticies=t.getTriangle(i);let s=g(n,o,r);if(s)return s}}}import{Vector as I}from"@papit/game-vector";function Vt(e,t){let r=I.Random,n=[],o=[],c={};for(;C(n,o););}function C(e,t){if(e.length===0||e.length!==t.length)return!0;for(let r=0;r<e.length;r++)if(e[r].toString()!==t[r].toString())return!0;return!1}export{h as AABB,J as CircleIntersection,Vt as GJK,y as LineIntersection,bt as SAT,V as SegmentIntersection,K as isPointInCircle,it as isPointInPolygonRayCasting,ct as isPointInPolygonTriangles,R as isPointInRectangle,v as isPointInTriangle};
