var o={z:!1,round:!0};var n=class{constructor(t,e=0,s=0){typeof t=="object"?(this.x=t.x||0,this.y=t.y||0,this.z=t.z||0):(this.x=t,this.y=e,this.z=s)}get magnitude(){return n.Magnitude(this)}get angle(){return Math.atan2(this.y,this.x)}set magnitude(t){let e=this.angle;this.x=Math.cos(e)*t,this.y=Math.sin(e)*t}set angle(t){let e=this.magnitude;this.x=Math.cos(t)*e,this.y=Math.sin(t)*e}set(t,e=0,s=0){let r=n.toVector(t,e,s);return this.x=r.x,this.y=r.y,this.z=r.z,this}add(t,e=0,s=0){let r=n.toVector(t,e,s);return this.x+=r.x,this.y+=r.y,this.z+=r.z,this}sub(t,e=0,s=0){let r=n.toVector(t,e,s);return this.x-=r.x,this.y-=r.y,this.z-=r.z,this}divide(t,e=0,s=0){let r=n.toVector(t,e,s);return this.x/=r.x,this.y/=r.y,this.z/=r.z,this}mul(t,e=0,s=0){let r=n.toVector(t,e,s);return this.x*=r.x,this.y*=r.y,this.z*=r.z,this}Add(t,e=0,s=0){let r=n.toVector(t,e,s),i=n.Copy(this);return i.x+=r.x,i.y+=r.y,i.z+=r.z,i}Sub(t,e=0,s=0){let r=n.toVector(t,e,s),i=n.Copy(this);return i.x-=r.x,i.y-=r.y,i.z-=r.z,i}Divide(t,e=0,s=0){let r=n.toVector(t,e,s),i=n.Copy(this);return i.x/=r.x,i.y/=r.y,i.z/=r.z,i}Mul(t,e=0,s=0){let r=n.toVector(t,e,s),i=n.Copy(this);return i.x*=r.x,i.y*=r.y,i.z*=r.z,i}get opposite(){return this.mul(-1)}get Opposite(){return n.toVector(this).opposite}normalise(){let t=this.magnitude;return this.x/=t,this.y/=t,this.z/=t,this}toString(t){let e={...o,...t||{}},s="";return e.round?s=`${Math.round(this.x*100)/100}, ${Math.round(this.y*100)/100}`:s=`${this.x}, ${this.y}`,e.z&&(e.round?s+=", "+Math.round(this.z*100)/100:s+=", "+this.z),`[${s}]`}dot(t){return this.x*t.x+this.y*t.y+this.z*(t.z||1)}draw(t,e="black"){this.drawDot(t,e)}drawDot(t,e="black",s=1){t.beginPath(),t.arc(this.x,this.y,s/2,0,Math.PI*2),t.fillStyle=e,t.fill(),t.closePath()}copy(){return new n(this.x,this.y,this.z)}static Multiply(t,e){return new n(t).mul(e)}static Divide(t,e){return new n(t).divide(e)}static Add(t,e){return new n(t).add(e)}static Subtract(t,e){return new n(t).sub(e)}static CrossProduct(t,e){return new n(t.y*(e.z||1)-(t.z||1)*e.y,(t.z||1)*e.x-t.x*(e.z||1),t.x*e.y-t.y*e.x)}static Cross(t,e){return t.x*e.y-t.y*e.x}static Magnitude(t){return Math.sqrt(t.x*t.x+t.y*t.y)}static Distance(t,e){return n.Subtract(t,e).magnitude}static Perpendicular(t,e,s="clickwise"){let r=n.Subtract(e,t);return s==="clockwise"?new n(-r.y,r.x):new n(r.y,-r.x)}static Normalise(t){let e=new n(t);return e.normalise(),e}static Dot(t,e){return n.toVector(t).dot(e)}static Angle(t){return Math.atan2(t.y,t.x)}static toVector(t,e=0,s=0){if(typeof t=="number")return new n(t,e!=null?e:t,s!=null?s:t);if(t instanceof n)return t;if(typeof t=="object")return new n(t);throw new Error(`This ${t} could not be reshaped into a vector`)}static Copy(t){return new n(t)}static get Zero(){return new n(0,0,0)}static get Random(){return new n(-1+Math.random()*2,-1+Math.random()*2,-1+Math.random()*2)}static Draw(t,e,s="black",r=1){n.toVector(t).drawDot(e,s,r)}};export{o as DEFAULT_PRINT_SETTINGS,n as Vector};
